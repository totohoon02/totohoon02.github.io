# 🗃️ 데이터베이스 동시성 제어 방법

동시성 제어는 **데이터의 일관성과 무결성**을 유지하기 위한 핵심 메커니즘

---

## 🔁 MVCC (Multi-Version Concurrency Control)

**여러 버전의 데이터를 유지하여 동시성을 보장하는 방식**

### ✅ 동작 방식

- 트랜잭션 시작 시 **일관된 스냅샷**을 기반으로 데이터를 읽음
  - 레코드 단위로 복제
  - 변경이 있을 때만 생성
- **읽기 작업은 잠금 없이 수행**
- 쓰기 작업은 새 버전의 데이터를 생성

### ✅ 장점

- 읽기 작업과 쓰기 작업의 **충돌이 없음**
- **읽기 성능 우수** → 읽기 중심의 시스템에 적합
- 잠금을 사용하지 않아 **데드락(Deadlock) 위험 없음**
- 팬텀 리드 방지를 위한 **갭 락(Gap Lock)**, **넥스트 키 락(Next-Key Lock)** 사용

#### 팬텀리드

```sql
TRX A: SELECT * FROM my_table; -- reuslt: 5
TRX B: INSERT INTO (name, my_id) VALUES ("B", "1");
TRX A: SELECT * FROM my_table; -- result: 6
```

- 처음에는 없던 행이 새로 생김

### ⚠️ 단점

- 여러 버전의 데이터를 관리하므로 **저장 공간을 더 많이 차지**
- 오래된 트랜잭션이 GC 지연 원인이 될 수 있음

---

## 🔒 Lock-Based Concurrency Control

**잠금을 통해 동시성 제어를 수행하는 전통적인 방식**

### ✅ 동작 방식

- 데이터 접근 시 **공유 잠금(읽기)** 또는 **배타 잠금(쓰기)** 을 설정
- 다른 트랜잭션은 잠금이 해제되기 전까지 해당 데이터 접근 불가

#### Locking Scenario

- 1번 트랜젝션 - 공유락

  - 2번 트랜젝션 - 읽기
    - 동시 처리
  - 2번 트랜젝션 - 쓰기
    - 대기

- 1번 트랜젝션 - 배타락
  - 2번 트랜젝션 - 읽기
    - 1번 트랜젝션의 데이터 쓰기 가능성, 대기
  - 2번 트랜젝션 - 쓰기
    - 대기

### ✅ 장점

- 데이터의 **정합성과 무결성 보장**
- 구현이 비교적 단순하고 직관적

### ⚠️ 단점

- **잠금 충돌로 인한 성능 저하**
- **데드락(Deadlock)** 발생 가능
- 많은 동시 요청에 **스케일링이 어려움**

#### 데드락

- 서로 다른 트랜젝션이 상대가 필요한 자원을 점유, 영원히 대기
- DBMS가 감지해서 한 쪽을 강제 종료

---

## 🤝 실제 사용 예: MySQL InnoDB 엔진

InnoDB는 **MVCC + Lock-Based** 전략을 혼합하여 사용함:

| 트랜잭션 종류                 | 제어 방식                     |
| ----------------------------- | ----------------------------- |
| 읽기 (SELECT)                 | MVCC (잠금 없음, 스냅샷 읽기) |
| 쓰기 (INSERT, UPDATE, DELETE) | 잠금 기반 제어 사용           |

- 읽기 성능은 MVCC로 확보
- 쓰기 성능과 정합성은 잠금으로 확보

---

## 💡 어떤 방식을 사용해야 할까?

| 기준        | MVCC             | Lock-Based              |
| ----------- | ---------------- | ----------------------- |
| 성능        | 읽기 중심에 적합 | 읽기/쓰기 균형형에 적합 |
| 데드락 위험 | 없음             | 있음                    |
| 일관성 보장 | 스냅샷 기반      | 잠금 기반               |
| 저장 공간   | 많이 필요        | 상대적으로 적음         |

> ✅ **현대적인 DBMS는 대부분 MVCC와 Lock을 적절히 병행 사용하여 장단점을 보완**

---
