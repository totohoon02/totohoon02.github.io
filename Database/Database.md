## What is Transcation?

- SQL 모음
- 작업의 단위
- Lifespan: BEGIN → COMMIT → ROLLBACK
- 커밋은 언제 발생하는가?
- 트랜잭션 중 에러가 발생한다면?

## Atomicity

- 트랜잭션 내의 모든 쿼리는 성공해야 한다.
- 만약 한개라도 실패 하면 모든 쿼리는 롤백되어야 한다.

## Isolation

트랜잭션이 동시에 실행될 때, 데이터의 정합성을 유지하기 위한 격리 수준을 설정 

격리 수준이 낮으면 성능이 향상되지만 데이터 정합성 문제가 발생

### **트랜잭션 경쟁 상태로 인한 정합성 문제**

1. **Dirty Read (더티 리드)**
    - 커밋되지 않은 데이터를 읽음
    - 롤백될 가능성이 있는 데이터를 읽어 잘못된 결과를 초래할 수 있음
2. **Non-Repeatable Read (비반복적 읽기)**
    - 동일한 데이터를 두 번 조회할 때, 그 사이에 다른 트랜잭션이 값을 변경하여 조회 결과가 다르게 나타남
    - 데이터를 다시 조회할 때 이전과 다른 결과가 나올 수 있음
3. **Phantom Read (팬텀 리드)**
    - 트랜잭션 중에 다른 트랜잭션이 새로운 데이터를 삽입하여 조회 결과가 달라지는 현상
    - 기존 데이터의 수정이 아니라 새로운 행이 추가되어 발생

### **Isolation Level (격리 수준)**

각 격리 수준은 위의 정합성 문제를 방지하는 정도에 따라 나뉘며, 성능과 데이터 정합성 간의 트레이드오프가 존재

### **1. Read Uncommitted (읽기 미확정)**

- 가장 낮은 격리 수준, **No Isolation**
- 다른 트랜잭션이 **커밋되지 않은 변경 사항(Dirty Read 포함)을 읽을 수 있음**
- Dirty Read, Non-Repeatable Read, Phantom Read 발생 가능
- **성능은 높지만 데이터 정합성이 보장되지 않음**

### **2. Read Committed (읽기 확정)**

- **커밋된 데이터만 읽을 수 있음** (Dirty Read 방지)
- Non-Repeatable Read와 Phantom Read는 여전히 발생 가능
- 대부분의 데이터베이스에서 기본 격리 수준으로 사용됨 (예: Oracle, SQL Server)
- 성능과 데이터 정합성 간의 균형이 좋음

### **3. Repeatable Read (반복 가능 읽기)**

- 트랜잭션 동안 같은 데이터를 반복 조회해도 **일관된 결과를 보장**
- **Non-Repeatable Read 방지** (트랜잭션이 끝날 때까지 다른 트랜잭션이 해당 데이터를 수정할 수 없음)
- 하지만 **Phantom Read는 여전히 발생 가능**
- MySQL에서 기본적으로 사용됨

### **4. Snapshot (스냅샷 격리)**

- 트랜잭션이 시작될 때의 데이터 스냅샷을 유지하여 **커밋된 데이터라도 트랜잭션 시작 이후 변경된 데이터는 보이지 않음**
- **MVCC (Multi-Version Concurrency Control, 다중 버전 동시성 제어)** 방식을 사용하여 구현
- Dirty Read, Non-Repeatable Read 방지, 일부 DBMS에서는 Phantom Read도 방지 가능
- 성능은 Serializable보다 높지만 높은 동시성 제어가 필요함
- PostgreSQL에서 `SERIALIZABLE SNAPSHOT ISOLATION`으로 구현됨

### **5. Serializable (직렬화 가능)**

- 가장 높은 격리 수준, **트랜잭션이 순차적으로 실행되는 것처럼 보이게 함**
- Dirty Read, Non-Repeatable Read, Phantom Read 모두 방지
- **모든 트랜잭션을 직렬화하여 동시 실행을 제한** → 성능 저하 발생 가능
- 레코드 또는 테이블 수준의 락을 사용하거나 MVCC를 활용하여 구현됨
- 높은 데이터 정합성이 필요할 때 사용 (예: 금융 시스템, 회계 시스템)

## Consistency

- 데이터 자체의 일관성(기존의 데이터 형식과 일치하는지)
- 데이터 읽기의 일관성(트랜잭션 중 예상할 수 없는 데이터 변화가 없어야 함)
- 테이블 간 참조 무결성 - 외래 키 제약조건(같이 삭제된다던가)
- 트랜잭션 일관성 - 트랜잭션의 실행은 일관성을 유지해야함. 한 계좌에서 돈이 빠져나가면 다른 계좌에 똑같은 돈이 입금되어야 한다.
- 중복 및 동시성 제어 - 동일한 데이터 중복 방지, 동시에 데이터의 수정을 방지하는 동시성 제어 메커니즘 필요

동시성 제어

- 락킹
    - 트랜잭션이 실행되기 전 다른 트랜잭션이 접근하지 못하게 락
    - 락을 걸기 때문에 병목 발생
    - 종류
        - 공유락
            - 읽기는 가능, 쓰기는 대기
        - 배타 락
            - 읽기 쓰기 모두 차단
- 낙관적 동시성 제어(OCC)
    - 충돌 가능성이 낮을 경우 락하지 않고 최종 변경된 데이터를 비교해 충돌 감지
    - 버저닝을 통해서 변경여부 체크
    - 충돌 시 롤백
- 다중 버전 동시성 제어(MVCC)
    - 데이터 베이스의 여러 개의 버전을 유지해 동시에 읽기, 쓰기
    - 서로 영향을 받지는 않음
    - 락을 사용하지 않기 때문에 성능은 좋으나 버전의 수에 따라서 영향
- Serializable
    - 트랜잭션을 순차적 실행하는 것처럼 동작
    - 성능 저하가 심각해 실제로 사용되는 경우는 잘 없음

## Durability

- 데이터를 저장하는 과정
- 커밋된 트랜잭션은 휘발성 없는 저장 매체에 저장 되어야 한다.
- 디스크에 쓰는 것은 무거운 작업임
- 커밋을 한 순간 무슨 일이 있어도 데이터는 기록되어 있어야 한다.
