# OS

## 운영체제 개요

### 운영체제가 하는 일

- 프로세스 관리
- 메모리 관리
- 하드웨어 관리
- 파일 시스템 관리

### 운영체제의 발전

- 어떻게 하면 CPU를 효율적으로 사용할 수 있을까?
- 낭비되는 시간을 줄인다.
- CPU의 사용률을 높이는 방법

### 운영체제의 구조

- 커널
  - 사용자
    - 인터페이스를 통해 접근
    - CLI, GUI
  - 어플리케이션
    - 시스템 콜을 통해 커널에 접근
  - 하드웨어
    - 드라이버를 통해 커널에 접근

### 하드웨어 구조

- 폰노이만 구조

  - CPU와 메모리를 연결하는 버스
  - 메모리의 소프트웨를 저장해 사용

- 메인보드

  - CPU
  - 메모리
  - 주변 장치

- CPU

  - ALU
    - 실제 연산 수행
  - CU
    - 장치들의 동작 제어
  - 레지스터
    - 데이터를 임시 보관

- 메모리
  - RAM
    - Random Access Memory
    - 데이터를 빠르게 읽고 쓸 수 있는 메모리
    - 휘발성 메모리
    - 프로세스가 실행되는 메모리
  - ROM
    - Read Only Memory
    - 데이터를 읽을 수만 있고 쓸 수 없는 메모리
    - 비휘발성 메모리
    - BIOS(컴퓨터 부팅을 위한 프로그램)

## 프로세스와 쓰레드

### 프로그램과 프로세스

- 프로그램

  - 저장장치에 저장된 명령의 집합체(코드와 데이터)

- 프로세스
  - 실행 중인 프로그램
  - 프로그램이 메모리에 로드된 상태
  - CPU가 실행하는 단위

### 프로세스의 구조

- Code 영역
  - 실행되는 코드가 저장된 영역
- Data 영역
  - 전역 변수와 정적 변수가 저장된 영역
- Stack 영역
  - 지역변수
  - 함수 호출과 관련된 정보가 저장된 영역
- Heap 영역
  - 동적으로 할당된 메모리가 저장된 영역
  - new / malloc() / free()

### 컴파일 과정

- 전처리기
  - 필요한 전처리와 매크로를 처리
- 컴파일
  - 고수준의 프로그래밍 언어를 저수준의 어셈블리어로 변환
- 어셈블러
  - 어셈블리어를 기계어로 변환
- 링커
  - 여러 개의 객체 파일을 하나의 실행 파일로 변환

### CPU 관점에서 보는 프로세스 실행

```Java
int num1 = 5;
int num2 = 6;
int result = num1 + num2;
```

- 제어장치가 명령어를 읽고 num1, num2를 읽고 레지스터에 저장
- ALU가 num1과 num2를 더하고 결과를 레지스터에 저장
- 제어장치가 레지스터에서 결과를 가져와서 메모리에 저장

### 멀티프로그래밍과 멀티프로세싱

- 멀티프로그래밍

  - 메모리에 여러 프로그램이 동시에 실행
  - CPU가 프로세스를 번갈아가며 실행

- 멀티프로세싱

  - 여러 개의 CPU가 동시에 실행
  - 여러 개의 프로세스를 동시에 실행, 다대다

- PCB(Process Control Block)
  - 프로세스의 상태를 관리하는 구조체
  - 프로세스의 메모리 주소
  - 프로세스의 상태
  - 프로세스의 우선순위
  - 프로세스의 ID

### 프로세스의 상태

- 생성
- 준비
- 대기
- 실행
- 종료

준비와 실행을 스케줄링에 따라 반복
대기상태 : 입출력 대기

### 컨텍스트 스위칭

- 현재 프로세스가 실행 중인 상태를 저장
- 다음 프로세스가 실행 중인 상태를 복구
- 실행
- CPU 점유시간, 인터럽트로 인해 발생

### 프로세스 생성

- 더블클릭
- 빈 스택, 빈 힙 생성
- PCB 생성
- 이후 생성되는 프로세스들은 부팅시 실행되는 0번 프로세스를 복사해서 실행
- 코드와 데이터 영역은 자신의 값으로 덮어쓰기
- 좀비 프로세스: 프로세스가 종료되지 못하고 메모리에 접근 불가능한 상태로 유지

### 쓰레드

- 프로세스 내에서 동시에 실행되는 여러 개의 실행 단위
- PCB, 코드, 데이터, 힙 공유
- 스택은 독립
- TCB(Thread Control Block)

### 프로세스 vs 쓰레드

- 프로세스
  - 메모리 공간이 독립
  - 컨텍스트 스위칭이 발생
  - 프로세스 간 통신(IPC)의 큰 오버헤드드
- 쓰레드
  - 메모리 공간이 공유
  - 컨텍스트 스위칭이 발생하지 않음
  - 작은 오버헤드, 공유 데이터의 문제 발생 가능성

## CPU 스케줄링

- 프로세스에게 CPU를 어떻게 잘 분배할 것인가?

### 다중 큐

- 준비 상태와 대기 상태는 큐로 관리
- 실행 상태에서 준비 상태로 갈 때 OS는 해당 프로세스를 프로세스의 우선순위에 따라 다른 큐로 이동
- 준비 상태인 프로세스 중 적당한 프로세스를 선택하여 실행 상태로 이동
- I/O 처리를 위한 큐가 있고, 인터럽트 발생 시 다시 준비 큐로 이동

### 스케줄링 목표

- 리소스 사용률 최적화
- 오버헤드 최소화
- 공평성(시스템의 목표에 따라 다르게 적용)
- 처리량
- 대기시간 최소화
- 응답시간 최소화

각 목표는 트레이드 오프 관계를 가짐

### 스케줄링 알고리즘

- FIFO
  - First In First Out
  - 먼저 들어온 프로세스가 먼저 실행
  - 처리 시간이 긴 프로세스로 인해 병목 현상 발생 가능성
  - 콘보이 효과
- SJF
  - Shortest Job First
  - 최소 실행 시간을 가진 프로세스가 먼저 실행
  - 처리 시간이 긴 프로세스가 무한 대기 현상 발생 가능성
- RR
  - Round Robin
  - 일정 시간만큼 실행 후 다른 프로세스로 이동
  - 실행된 프로세스는 큐의 뒤로 이동
  - 타임슬라이스 상황에 따라 성능이 달라짐
  - 컨텍스트 스위칭으로 인해 타임슬라이스를 짧게 설정하면 오버헤드가 증가
- MLFQ
  - Multi Level Feedback Queue
  - 가장 일반적으로 사용되는 스케줄링 알고리즘
  - RR의 업그레이드 버전
  - 다중 큐
  - 프로세스의 우선순위에 따라 다른 큐로 이동
  - 실행 시간을 초과하면 우선 순위가 낮고 타임슬라이스가 긴 큐로 이동

## 프로세스 동기화

### IPC(Intert Process Communication)

- 프로세스 간 통신
- 메시지 전달 방식
  - 프로세스 간 메모리를 공유하지 않고 메시지를 전달
  - 파이프
    - 운영체제가 생성한 통로로 통신
    - 단방향 통신
  - 메시지 큐
    - 임시 저장소인 큐에 메시지를 보관
    - 메시지 큐에 메시지를 보관하고 다른 프로세스가 메시지를 가져가서 처리
    - 양방향 통신
  - 소켓
    - 클라이언트, 서버 구조
    - 네트워크를 통해 통신
    - 양방향 통신
    - 비동기 통신
- 공유 메모리 방식
  - 메모리 공유
  - 세마포어
  - 뮤텍스
  - 모니터
  - 메모리를 공유하기 때문에 동기화 문제가 발생할 수 있음

### 공유 자원과 임계구역

- 공유자원

  - 여러 프로세스가 동시에 접근할 수 있는 자원
  - 동기화 문제(경쟁 조건)

- 임계구역

  - 동시에 접근할 수 없는 자원

- 상호 배제 프로세스
  - 임계영역에는 동시에 접근할 수 없도록 제어
  - 여러 요청에도 하나의 프로세스의 접근만 허용

### 세마포어

- 상호배제 메커니즘
- 프로세스가 임계영역에 진입하기 전에 세마포어를 획득
- 프로세스가 임계영역을 빠져나가기 전에 세마포어를 해제
- 세마포어의 값이 0이면 임계영역에 진입할 수 없음
- 세마포어의 값이 1이면 임계영역에 진입할 수 있음
- 세마포어의 값이 0이면 프로세스는 세마포어를 획득할 때까지 대기
- wait, siganl 함수를 잘못 호출할 가능성(프로그래머의 실수수)

### 모니터

- 상호배제 메커니즘
- 언어에서 지원 레벨
- syncronized 키워드가 붙은 메서드
- 한 프로세스에서 syncronized 메서드를 호출할 때 다른 프로세스는 어떠한 메서드도 호출할 수 없음

## 데드락

- 여러 프로세스가 서로의 자원을 필요로 하여 서로를 기다리는 상황
- 공유자원으로 인해 발생

### 교착상태의 필요조건

- 상호배제
  - 사용중인 자원은 다른 프로세스가 사용할 수 없음
- 비선점
  - 사용중인 자원을 뺏을 수 없음
- 점유와 대기
  - 프로세스가 이미 사용중인 자원을 대기 중인 상태
- 원형대기
  - 프로세스가 서로 다른 자원을 필요로 하여 서로를 기다리는 상황

한가지 조건이라도 충족되지 않는다면 교착상태는 발생하지 않음

### 교착상태의 해결방법

- 교착상태 회피
  - 교착상태가 발생하지 않을 정도로만 자원을 할당
  - 운영체제는 안정상태를 유지하려고 함
  - 은행원 알고리즘
    - 여유가 있는 경우 자원을 할당
    - 필요 자원 요구가 적절한 프로세스에 먼저 할당
    - 비용이 비싸다. 큰 대기 시간
- 교착상태 검출
  - 가벼운 교착상태 검출
    - 프로세스가 일정 시간동안 실행되지 않는다면 교착상태로 판단
    - 일정 시간마다 스냅샷 생성, 롤백(종료)
    - I/O 작업으로 대기중인 프로세스를 교착상태로 판단할 가능성 존재
  - 무거운 교착상태 검출
    - 그래프를 이용해 교착상태를 검출
    - 교착상태를 일으킨 프로세스를 강제 종료
    - 오버헤드가 큼

## 메모리

### 메모리의 종류

- 휘발성 메모리
  - 레지스터
  - 캐시
  - 메인메모리(RAM)
- 비휘발성 메모리
  - 보조메모리(ROM)
- 메인메모리는 레지스터를 이용해 계산
- 캐시는 메인메모리의 일부를 빠르게 접근할 수 있도록 저장

### 메모리와 주소

- 1byte 단위로 주소를 구분
- 사용자의 논리 주소 접근을 물리 주소로 변환
- 메모리 관리자를 통해 변환

### 메모리 할당 방싱

- 연속 메모리 할당
  - 정적할당
    - 내부 단편화
      - 동일한 크기를 할당
      - 내부에 사용하지 않는 메모리가 존재
      - 할당 크기보다 큰 프로세스 실행 불가
  - 동적할당
    - 외부 단편화
      - 할당 위치에 따라 메모리가 단편화 됨
      - 중간에 낀 작은 바이트 사용 불가

## 가상메모리
