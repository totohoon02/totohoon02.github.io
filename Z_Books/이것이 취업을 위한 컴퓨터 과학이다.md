# Computer Science

- 특정 코드 혹은 프로그램이 어떻게 동작하며, 왜 특정 성능을 내는지에 대한 `근거`를 제시하고 `설명`하는 능력
- 프로그램의 목적은 `제대로 동작하게 만드는 것`
- 근거를 이해하지 못하고 복붙한 코드는 스파게티가 된다.
- 실행 원리를 이해하고 설명하기 위해서는 `컴퓨터 과학`을 `이해`해야 한다.

# 컴퓨터 구조

<details>
<summary>Contents</summary>
<div markdown="1">

## 컴퓨터 구조의 큰 그림

### 컴퓨터가 이해하는 정보

- `데이터`와 `명령어`
- 수행할 `동작`과 `대상`으로 구성
- 코드(프로그래밍 언어)는 내부적으로 데이터와 명령어로 변환되어 실행된다.

```
더하기 A와 B를
출력 'Hello World'
```

- `CPU`가 명령어를 실행

### 컴퓨터의 핵심 부품

- `CPU`
  - 명령어를 읽어 실행
  - `ALU`(계산기) + `CU`(제어신호) + `register`(임시 저장)
- `주기억장치` : `메모리`(RAM), `캐시 메모리`(필요한 데이터를 임시로 저장)
- `보조기억장치` : `SSD`
- `입출력장치` : `키마모프`

> 컴퓨터의 핵심 부품들은 모두 `메인 보드`에 연결되어 있고 `버스`를 통해 통신

## 컴퓨터가 이해하는 정보

### 데이터 표현

- CPU는 `0`과 `1`만을 이해한다.
- 1byte는 2^8(256)개의 정보를 표현
- 64비트에서 부호(1), 가수(11), 소수(52)
- 문자 표현: 유니코드
  - 유니코드에 부여된 값을 인코딩해 표현
  - utf-8
- 파일 표현: base64

### 명령어

- 동작(연산 코드)과 대상(오퍼랜드 / 주소)
- 프로그래밍 언어 > 어셈블리어 > 기계어
- 명령어 사이클
  - 명령어의 실행은 인출 사이클과 실행 사이클의 반복

## CPU

### 레지스터

- 데이터와 명령어를 임시 저장
- 프로그램 카운터
  - 다음 읽어들일 명령어의 주소
- 명령어 레지스터
- 범용 레지스터
  - 데이터, 명령어 둘 다 저장
- 플래그 레지스터
  - 실행 결과에 대한 정보를 저장
- 스택 포인터
  - 메모리 스택의 탑을 가리키는 레지스터
  - 스택이 채워진 정도

### 인터럽트

#### 비동기 인터럽트

- CPU의 작업을 방해하는 신호
- 동기 인터럽트(`Exception`)
  - CPU에 의해서 발생
  - 예외적인 상황 처리
- 비동기 인터럽트
  - 입출력장치에 의해서 발생
  - 알림과 같은 역할
  - I/O작업은 CPU에 비해 현저히 느림
  - CPU가 I/O작업을 대기하지 않고 작업이 끝났을 때 신호를 보낸다
  - 그동안 CPU는 다른 작업 처리

#### 예외

- CPU는 예외가 발생하면 하던 일을 중단하고 예외를 처리
- 폴트
  - 예외 처리 직후 예외가 발생한 명령어부터 실행
- 트랩
  - 예외 처리 직후 예외가 발생한 다음 명령어부터 실행
- 중단
  - 프로그램을 강제 중단

### CPU 성능 향상을 위한 설계

#### 클럭 속도

- 명령어 처리 속도
- CPU의 속도

### 멀티코어와 멀티스레드

- 멀티 코어: 명령어 처리 부품이 여러 개
- 스레드
  - 하드웨어 스레드
    - 하나의 코어가 동시에 처리하는 명령어 단위
  - 소프트웨어 스레드
  - 하나의 프로그램에서 독립적으로 실행되는 단위
- 병렬성: 물리적으로 여러 작업을 동시에 실행
- 동시성: 여러 작업이 동시에 실행되는 것 처럼 보이게 함

## 메모리

### RAM

- 실행 중인 프로그램이 저장
- 휘발성
- Random Access: 특정 주소에 바로 접근 가능
- DRAM
  - 시간이 지나면 데이터가 점차 사라지는 RAM
  - 일반적인 RAM
- SRAM
  - 시간이 지나도 데이터가 사라지지 않는 RAM
  - 캐시 메모리
- SDRAM
  - 클럭 신호와 동기화된 DRAM
  - 더 빠름
- DDR SDRAM
  - 대역폭이 넓은 SDRAM
  - DDR4 할때 그거임

### 빅 엔디안 vs 리틀 엔디안

- 메모리에 바이트를 밀어넣는 순서
- 1q2w3e4r(메모리 주소 증가)
  - 빅 엔디안 1q2w3e4r / 낮은 주소번지부터
    - 가독성
  - 리틀 엔디안 4r3e2w1q / 높은 주소번지부터
    - 수치 계산 편리

### 캐시 메모리

- CPU에서 매 번 RAM에 접근하기헤는 너무 느리다
- CPU와 RAM 사이의 임시 저장소
- 히트 & 미스
  - 캐시 메모리는 CPU가 사용할 법한 것을 가져와 저장
  - 예측이 맞은 빈도와 틀린 빈도

### 참조 지역성

- 캐싱할 데이터를 예측하는 방법
- 시간 지역성
  - 최근 접근했던 메모리에 다시 접근하려는 경향
  - 변수
- 공간 지역성
  - 최근 접근한 메모리 근처 메모리에 접근하려는 경향
  - 배열

> 캐싱은 데이터 접근에 빠른 성능을 보장, 데이터 일관성을 유지하기 위한 책임이 필요하다

## 보조기억장치와 입출력 장치

### RAID

- 기억장치: 플래시 메모리 기반 저장장치
- RAID: 여러 개의 보조기억장치를 한 개의 장치처럼 사용

### 입출력 기법

- CPU - 장치 컨트롤러 - 장치 드라이버
- CPU에서 드라이버 프로그램을 실행한다.
</div>
</details>

# 운영체제

<details>
<summary>Contents</summary>
<div markdown="1">

## 운영체제의 큰 그림

운영체제도 프로그램이다.

### 운영체제의 역할

컴퓨터 부품에 자원을 할당하고 효율적으로 사용되도록 관리

- CPU 스케줄링
- 메모리 관리
- 파일 관리
- 프로세스 및 스레드 관리

### 시스템 콜과 이중 모드

- 운영체제도 일종의 프로그램이다. 메모리에 적재되어야 한다.
- 운영체제는 커널 영역이라는 공간에 따로 적재된다.
- 운영체제의 기능을 사용하기 위해서는 커널 영역에 적재된 코드를 실행해야 한다.
- 시스템콜
  - 응용 프로그램이 운영체제의 코드를 호출하는 방법
  - 시스템 콜을 이용해 하드웨어 자원을 사용한다.
  - 시스템 콜을 호출하면 소프트웨어 인터럽트 발생, 커널모드로 전환되어 코드 실행, 실행이 끝나면 사용자 모드로 다시 전환된다.

## 프로세스와 스레드

### 프로세스

- 포어그라운드 프로세스
- 백 프로세스
  - 데몬(서비스)
- 코드
- 데이터
  - 정적 변수, 전역 변수
- 힙
  - 프로그램 실행 도중 할당되는 메모리
  - 메모리 누수, GC
- 스택
  - 일시적으로 사용할 변수
  - 매개 변수, 지역 변수, 함수의 호출 정보
- PCB
  - 프로세스 관리를 위한 정보 저장
  - 프로세스 ID
  - 레지스터
  - 프로세스 상태
  - CPU 스케줄링 정보
  - 메모리 관련 정보
  - 파일 및 입출력 정보

프로세스의 CPU 사용은 시간에 따라 제한. PCB의 프로세스 실행 정보를 백업(Context)

- 프로세스는 생성 이후 준비 -> 실행 반복
- I/O 같은게 들어오면 대기
- 끝나면 종료 상태

### 멀티프로세스와 멀티스레드

- 멀티프로세스
  - 동시에 여러 프로세스가 실행
  - 자원을 독립적으로 사용
- 멀티스레드
  - 한 프로세스 내에 여러 스레드가 실행
  - 자원을 공유

## 동기화와 교착 상태

- 다수의 프로세스/스레드가 공유자원에 동시에 접근한 경우
- 공유 자원에 접근하는 코드 중 동시에 실행했을 때 문제가 발생할 수 있는 코드를 `임계 구역`이라고 함
- 임계 구역에서 코드 실행으로 인해 발생하는 문제 `레이스 컨디션`

### 동기화

- 실행 순서 제어
- 상호 배제
  - 동시에 접근해서는 안되는 자원 설정

> 두 가지 조건을 준수하며 실행

### 뮤텍스 락

- 동시 접근이 불가능하도록 상호 배제를 보장
- lock을 획득/해제
- lock을 획득하지 못하면 대기

```python
import threading

lock = threading.Lock()

def critical_section(thread_id):
    print(f"Thread-{thread_id} trying to acquire lock...")
    lock.acquire()
    try:
        print(f"Thread-{thread_id} entered critical section")
        # 공유 자원 작업
    finally:
        print(f"Thread-{thread_id} releasing lock")
        lock.release()

# 여러 스레드 실행
for i in range(3):
    t = threading.Thread(target=critical_section, args=(i,))
    t.start()
```

### 세마포

- 공유 자원이 여러 개인 경우
- `wait` 호출 시 공유 가능한 자원의 갯수(`S`)를 확인
- `S`가 0 미만일 경우 이후 스레드는 대기

```python
import threading
import time

# 자원 개수 2개 (예: 프린터가 2대)
semaphore = threading.Semaphore(2)

def use_resource(thread_id):
    print(f"Thread-{thread_id} waiting for resource...")
    semaphore.acquire()
    try:
        print(f"Thread-{thread_id} using resource")
        time.sleep(1)  # 자원 사용 중
    finally:
        print(f"Thread-{thread_id} releasing resource")
        semaphore.release()

# 5개의 스레드 실행
for i in range(5):
    t = threading.Thread(target=use_resource, args=(i,))
    t.start()
```

| 항목      | 뮤텍스 락                  | 세마포어             |
| --------- | -------------------------- | -------------------- |
| 자원 수   | 1개 (단일 접근)            | N개 (다중 접근)      |
| 함수      | `acquire()`, `release()`   | 동일                 |
| 대기 조건 | 락이 이미 사용 중이면 대기 | 자원 수가 0이면 대기 |

### 조건 변수와 모니터

- 조건변수
  - 실행 순서 제어 도구, 특정 조건 하에 프로세스를 실행/정지
- 모니터
  - 공유자원과 공유자원을 다루는 함수로 구성된 동기화 도구, 상호 배제 + 실행 순서 제어
  - 내부에 lock과 조건 변수를 포함

| 항목 | 조건 변수                   | 모니터                                             |
| ---- | --------------------------- | -------------------------------------------------- |
| 목적 | 실행 순서 제어              | 상호 배제 + 실행 순서 제어                         |
| 동작 | 조건 만족 시 스레드 깨움    | 내부에 조건 변수 + 락 포함                         |
| 사용 | `wait()`, `signal()`        | `monitor` 내 메서드로 구현                         |
| 예시 | 생산자-소비자 문제에서 대기 | 자바 `synchronized` 블록, 파이썬의 `with lock:` 등 |

```C
monitor BoundedBuffer {
    condition notFull, notEmpty;
    void put(Item item) {
        if (buffer is full)
            wait(notFull);
        // add item
        signal(notEmpty);
    }
    void get() {
        if (buffer is empty)
            wait(notEmpty);
        // remove item
        signal(notFull);
    }
}
```

### 스레드 세이프

- 동시에 접근해도 문제 없는 상태
- 스레드 세이프가 보장된 메서드 같은게 있다.

### 교착 상태

- 2개 이상의 프로세스가 상대방의 자원을 대기
- 어떤 프로세스도 진행 불가능

#### 교착 상태의 필요조건

- 상호 배제
  - 공유 자원을 하나의 프로세스만 이용 가능
- 점유와 대기
  - 공유 자원을 가진 상태에서 다른 자원 대기
- 비선점
  - 다른 스레드의 자원을 강제로 뺏을 수 없음
- 원형 대기
  - 자원 대기가 순환 형태

> 한가지라도 만족하지 않으면 교착상태는 발생하지 않음

#### 해결 방법

- 필요 조건 중 하나를 충족하지 못하게 한다.
- 교착 상태가 발생하지 않을 정도로만 자원 할당
- 검출 후 회복
  - 자원 선점
  - 강제 종료

## CPU 스케줄링

CPU 배분 방법

#### 우선순위

- PCB에 우선순위를 명시, 더 빨리, 많이 할당
- CPU 활용률이 높아지는 방향으로 할당한다.
  - I/O 집중 프로세스를 먼저 실행
  - I/O 대기, 리소스 반납
  - CPU 집중 프로세스 실행

#### 스케줄링 큐

- 자원을 사용하기 위해 대기하는 순서
- 준비 큐, 대기 큐
  - 준비 큐에 줄을 선다.
  - 순서대로 처리하지만 우선순위가 우선
  - 타이머 입터럽트 발생 시 다시 준비큐로
  - I/O는 대기 큐

#### 선점형 스케줄링과 비선점형 스케줄링

- 스케줄링은 일반적으로 프로세스의 실행이 끝나면 발생
- 선점형 스케줄링
  - CPU가 자원을 뺏어 다른 프로세스에 할당
  - I/O, 타이머 인터럽트
- 비선점형 스케줄링
  - 자원을 강제로 뺏지 못하고 실행이 완료될때 까지 대기

### 스케줄링 알고리즘

- FIFO(First In First Out)
  - 들어온 순서대로 처리
  - 대기시간이 길어질 수 있다.
- SJF(Short Job First)
  - 짧은거 먼저 처리
  - 짧은게 계속해서 들어올 경우 긴 작업 무한 대기
- RR(Round Robin)
  - 순서대로 처리 하되 타임 슬라이스(정해진 시간) 동안 작업 처리
  - 작업을 끝내지 못하면 다시 큐 맨뒤로
- SRT(Short Remaining Time)
  - SJF + RR
- 우선순위
  - 우선 순위가 낮은 작업들은 무한 대기
- 다단계 큐
  - 우선순위가 가장 높은 큐에 있는 작업 먼저
  - 큐 간 이동불가, 무한대기
- 다단계 피드백 큐 스케줄링
  - 프로세스들이 큐 간 이동 가능
  - 우선순위가 높은 작업이 타임슬라이스 동안 끝내지 못하면 하위 우선순위로 이동
  - CPU를 오래 사용해야하는 작업은 우선순위가 낮아짐
  - 우선순위 큐에서 오래 대기한 작업의 우선순위를 높임

## 가상 메모리

CPU는 어떻게 메모리에 적재된 프로세스의 주소를 인식하고 관리하는지?

### 물리 주소와 논리 주소

- CPU는 메모리 하드웨어 상의 물리 주소가 아니라 논리 주소 체계를 사용
- 논리 주소
  - 각 프로세스마다 0번지에서 시작하는 주소
  - 메모리 관리장치(MMU)를 통해 논리 주소를 물리 주소로 변환

### 스와핑과 연속 메모리 할당

- 스와핑
  - 오랫동안 사용되지 않은 프로세스를 보조기억창치로 스왑
  - 빈 공간에 다른 프로세스를 적재
- 연속 메모리 할당
  - 메모리들을 연속으로 배치
  - 외부 단편화 문제(50mb 짜리를 스왑, 30mb 실행 시 20mb는 사용 불가)

> 외부 단편화, 물리 메모리보다 큰 프로세스 실행 불가

### 페이징을 통한 가상 메모리

- 가상메모리
  - 프로그램의 일부만 메모리에 적재
  - 보조기억장치의 일부를 메모리처럼활용
  - 페이징
    - 논리 주소 공간을 일정한 크기(페이징) 으로 분할
    - 물리 주소 공간을 페이징과 동일한 크기의 프레임으로 분할
    - 페이지를 프레임에 할당
    - 페이지는 불연속적으로 배치된다.

> 전체 프로세스가 메모리에 적재될 필요가 없음

- 페이징 교체 알고리즘
  - FIFO
  - 최적 페이지
    - 사용 빈도가 가장 낮은 페이지
  - LRU(Least Recently Used)

## 파일 시스템

보조기억장치를 관리 하는 프로그램

</div>
</details>

# 자료구조

<details>
<summary>Contents</summary>
<div markdown="1">

## 자료구조의 큰 그림

데이터를 어떻게 다룰 것인가

### 배열과 연결리스트

- 배열
  - 요소들이 순차적으로 나열된 자료구조
  - 고유한 인덱스
  - 접근시간 O(1)
  - 수정시간 O(n)
- 연결 리스트
  - 노드로 구성된 순차적이지 않은 자료구조
  - 다음 노드에 대한 정보를 가지고 있음
  - 접근시간 O(n)
  - 수정시간 O(1)

### 스택과 큐

- 스택
  - Push, Pop
  - Last in First Out
- 큐
  - Enqueue, Dequeue
  - First in First Out

### 해시 테이블

- 키와 값으로 이루어진 자료구조
- 키를 특정한 알고리즘(해시 함수)을 통해 인덱스 생성
- 검색 속도가 빠르나 메모리 사용, 해시 충돌 문제

### 해시 충돌

- 서로 다른 키에 같은 해시 값이 대응되는 상황
- 체이닝
  - 충돌한 데이터를 연결리스트로 연결
  - 해시 테이블의 장점이 감소
- 개방 주소법
  - 단순하게 다음 인덱스에 저장
  - 데이터 군집화 현상
- 이중해싱
  - 2개의 해시 함수를 사용

### 트리

- 노드와 간선으로 이루어진 계층적 자료구조
- 차수
  - 자식 노드 의 수
- 레벨
  - 루트에서 해당 노드까지 간선의 수

#### 트리의 순회

```
      A
     / \
    B   C
   / \
  D   E
```

- 전위 순회
  - 루트에서 시작해서 왼쪽 우선으로 순회
- 중위 순회
  - 왼쪽에서 시작 루트, 오른쪽으로 순회
- 후위 순회
  - 왼쪽에서 오른쪽 까지 방문 후 루트 순회

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def preorder(node):
    if node:
        print(node.data, end=' ')  # 1. 루트
        preorder(node.left)        # 2. 왼쪽
        preorder(node.right)       # 3. 오른쪽

def inorder(node):
    if node:
        inorder(node.left)         # 1. 왼쪽
        print(node.data, end=' ')  # 2. 루트
        inorder(node.right)        # 3. 오른쪽

def postorder(node):
    if node:
        postorder(node.left)        # 1. 왼쪽
        postorder(node.right)       # 2. 오른쪽
        print(node.data, end=' ')   # 3. 루트

# 트리 구성
root = Node('A')
root.left = Node('B')
root.right = Node('C')
root.left.left = Node('D')
root.left.right = Node('E')

# 순회 실행
preorder(root) # 출력: A B D E C
inorder(root) # 출력: D B E A C
postorder(root) # 출력: D E B C A
```

#### 트리의 종류

- 이진트리
  - 자식 수가 2개 이하
- 포화 이진 트리
  - 리프 노드 제외 모두 자식 2개
- 완전 이진 트리
  - 포화 이진 트리인데 마지막 레벨의 노드 왼쪽부터 자식 존재
- 이진 탐색 트리
  - 현재 노드를 기준으로 자식 노드가 작은 값 / 큰 값을 가짐
  - 탐색 O(logn)
- 힙
  - 최댓값과 최솟값을 빠르게 찾는 용도
  - 루트 노드가 항상 최대/최소 유지

### 그래프

연결 관계를 표한한 자료구조

- 연결 그래프
  - 두 정점 사이에 경로 존재
- 비연결 그래프
  - 두 정점 사이에 경로가 존재하지 않음
- 방향 그래프
- 무방향 그래프
- 가중치 그래프

#### 그래프의 표현

- 인접 행렬 기반
  - N x N의 배열로 그래프를 표현
  - N개의 정점 사이의 연결을 표시

```python
'''
1 -> 2
4 -> 1
3 -> 4
'''

graph = [
  [0, 1, 0, 0],
  [0, 0, 0, 0],
  [0, 0, 0, 1],
  [1, 0, 0, 0]
]
```

- 인접 리스트 기반
  - 연결 리스트, 딕셔너리 같은 자료구조로 그래프 표현

```python
graph = {
    1: [2],
    4: [1],
    3: [4]
}
```

#### 깊이 우선 탐색

- 더 이상 방문 가능한 정점이 없을 때 까지 최대한 깊이 탐색
  - 한놈만 조진다.
- 재귀 방식 구현

```python
'''
         a
       / | \
      b  c  d
      |   \ /
      e    f
'''
from collections import defaultdict

graph = defaultdict(list)

edges = [
    ('a', 'b'),
    ('b', 'e'),
    ('a', 'c'),
    ('c', 'f'),
    ('a', 'd'),
    ('d', 'f')
]

# 무방향 그래프이므로 양쪽 다 연결
for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)


for u, v in edges:
    graph[u].append(v)

# DFS 함수 (재귀)
def dfs(node, visited=set()):
    if node in visited:
        return
    print(node, end=' ')
    visited.add(node)
    for neighbor in graph[node]:
        dfs(neighbor, visited)

dfs('a') # a b e c f d
```

#### 너비 우선 탐색

- 최대한 넓게 탐색
  - 분신술 같은 느낌임
- 큐를 이용해 구현

```python
'''
         a
       / | \
      b  c  d
      |   \ /
      e    f
'''
def bfs(start):
    visited = set()
    queue = deque([start])

    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node, end=' ')
            visited.add(node)
            for neighbor in sorted(graph[node]):  # 정렬하면 예측 가능
                if neighbor not in visited:
                    queue.append(neighbor)

bfs('a') # a b c d e f
```

#### 최단 경로 알고리즘

- 목적지 까지의 가중치가 최소가 되는 경로
- 다익스트라

  - 최단 거리 테이블에서 시작점을 제외한 모든 정점을 충분히 큰 수로 초기화
  - 시작점 방문
  - 인접 정점 방문
  - 경로 상의 가중치 합과 최단 거리 테이블 상의 값을 비교
  - 최단 거리를 갱신할 수 있으면 갱신
  - 방문하지 않은 정점 중 최단 거리가 작은 정점을 방문
  - 방문할 정점이 없을 때 까지 반복

| From | To  | Weight |
| ---- | --- | ------ |
| 1    | 2   | 2      |
| 2    | 3   | 10     |
| 2    | 4   | 2      |
| 2    | 5   | 5      |
| 4    | 5   | 1      |
| 5    | 3   | 2      |
| 5    | 6   | 3      |
| 6    | 3   | 2      |

| 정점 | 거리 |
| ---- | ---- |
| 1    | 0    |
| 2    | 999  |
| 3    | 999  |
| 4    | 999  |
| 5    | 999  |
| 6    | 999  |

시작점 1을 방문 -> 인접 정점은 2

- 정점 2에 이르는 가중치의 합과 테이블 비교

| 정점  | 거리  |
| ----- | ----- |
| 1     | 0     |
| **2** | **2** |
| 3     | 999   |
| 4     | 999   |
| 5     | 999   |
| 6     | 999   |

방문하지 않은 정점 중 최단 거리 정점(2)를 방문
정점 3, 4, 5의 최단거리

- 2 + 10 (1 -> 2 -> 3)
- 2 + 2 (1 -> 2 -> 4)
- 2 + 5 (1 -> 2 -> 5)

테이블 갱신

| 정점  | 거리   |
| ----- | ------ |
| 1     | 0      |
| 2     | 2      |
| **3** | **12** |
| **4** | **4**  |
| **5** | **7**  |
| 6     | 999    |

정점 중 최단 거리인 정점(4) 방문
4에서 갈 수 있는 정점은 정점(5)

- 가중치의 합 5 (1 -> 2 -> 4 -> 5)

테이블 갱신

| 정점  | 거리  |
| ----- | ----- |
| 1     | 0     |
| 2     | 2     |
| 3     | 12    |
| 4     | 4     |
| **5** | **5** |
| 6     | 999   |

정점(5) 방문
5에서 갈 수 있는 방문하지 않은 정점(3, 6)

- 가중치의 합

  - 7 (1 -> 2 -> 4 -> 3)
  - 8 (1 -> 2 -> 4 -> 6)

| 정점  | 거리  |
| ----- | ----- |
| 1     | 0     |
| 2     | 2     |
| **3** | **7** |
| 4     | 4     |
| 5     | 5     |
| **6** | **8** |

최단 거리 인 정점(3) 방문
정점(3)에 인접한 정점이 없음
정점(5)와 인접한 다른 정점(6) 방문
정점(6)과 인접한 정점(3) 방문

- 가중치의 합
  - 10 (1 -> 2 -> 4 -> 6 -> 3)
  - 기존 최단거리가 7이므로 갱신 x

더 이상 방문할 정점이 없으므로 탐색 종료
**1에서 각 지점에 이르는 최단거리**

| 정점 | 거리 |
| ---- | ---- |
| 1    | 0    |
| 2    | 2    |
| 3    | 7    |
| 4    | 4    |
| 5    | 5    |
| 6    | 8    |

```python
import heapq
from collections import defaultdict

# 그래프 정의
graph = defaultdict(list)
edges = [
    (1, 2, 2),
    (2, 3, 10),
    (2, 4, 2),
    (2, 5, 5),
    (4, 5, 1),
    (5, 3, 2),
    (5, 6, 3),
    (6, 3, 2)
]

for u, v, w in edges:
    graph[u].append((v, w))

def dijkstra(start):
    distance = defaultdict(lambda: float('inf'))
    visited = set()
    distance[start] = 0
    pq = [(0, start)]

    while pq:
        dist, node = heapq.heappop(pq)

        if node in visited:
            continue
        visited.add(node)

        for neighbor, weight in graph[node]:
            new_dist = dist + weight
            if new_dist < distance[neighbor]:
                distance[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))

    return dict(distance)
```

</div>
</details>

# 네트워크

<details open>
<summary>Contents</summary>
<div markdown="1">

## 네트워크의 큰 그림

### 네트워크 기본 구조

- 네트워크 토폴로지
  - 네트워크 노드 간 연결 구조
  - 망, 트리 등
- 호스트
  - 네트워크 요청을 주고 받는 노드
  - 클라이언트와 서버
- LAN
  - 로컬 망 통신
- WAN
  - 외부 망 통신
  - 인터넷
- 패킷 교환 네트워크
  - 큰 데이터를 `패킷`이라는 단위로 쪼개어 전송
  - 패킷은 `페이로드`와 `헤더`로 구성
- 주소 개념과 전송 방식
  - 패킷 헤더에 명시되는 목적지
  - IP, MAC
  - 유니 캐스트 1:1
  - 브로드 캐스트 전체

### 패킷을 주고 받는 과정

- 프로토콜

  - 패킷을 어떻게 주고 받을 지 정의
  - TCP/IP, UDP, HTTP
  - 목적에 따라 특징과 내용이 다르다

- OSI 7계층

| 계층 | 이름                         | 설명                                                 |
| ---- | ---------------------------- | ---------------------------------------------------- |
| 7    | 응용 계층 (Application)      | 사용자가 직접 접근하는 계층 (웹 브라우저, 이메일 등) |
| 6    | 표현 계층 (Presentation)     | 데이터 표현 형식 변환 (암호화, 압축 등)              |
| 5    | 세션 계층 (Session)          | 통신 세션 관리 (연결 설정, 유지, 종료)               |
| 4    | 전송 계층 (Transport)        | 신뢰성 있는 데이터 전송 (TCP/UDP)                    |
| 3    | 네트워크 계층 (Network)      | 주소 지정 및 경로 선택 (IP)                          |
| 2    | 데이터 링크 계층 (Data Link) | MAC 주소 기반 통신, 오류검출                         |
| 1    | 물리 계층 (Physical)         | 전기적 신호, 케이블, 하드웨어 전송                   |

- TCP/IP 모델

| TCP/IP 계층                            | 주요 역할                     | 대표 프로토콜        | OSI 계층 대응                 |
| -------------------------------------- | ----------------------------- | -------------------- | ----------------------------- |
| 4. 응용 계층 (Application)             | 사용자 기능 제공              | HTTP, FTP, SMTP, DNS | OSI 7~5계층 (응용~세션)       |
| 3. 전송 계층 (Transport)               | 통신 양 끝 간 신뢰성 보장     | TCP, UDP             | OSI 4계층 (전송)              |
| 2. 인터넷 계층 (Internet)              | 주소 지정, 라우팅             | IP, ICMP, ARP        | OSI 3계층 (네트워크)          |
| 1. 네트워크 접근 계층 (Network Access) | 실제 물리 전송, MAC 주소 기반 | Ethernet, Wi-Fi      | OSI 2~1계층 (데이터링크~물리) |

## 물리 계층과 데이터 링크 계층

### 이더넷

- 통신 매체를 통해 신호를 송수신하는 방법
- LAN 표준

## 네트워크 계층 - IP

다른 네트워크와 통신

### IP의 목적과 특징

- 목적
  - 주소 지정
    - 네트워크 상의 호스트 특정
    - IP 패킷에 송신/수신 주소 명시
    - MAC 주소는 발신인/수신인, IP 주소는 주소
    - 라우터를 통해 최적의 경로로 통신
  - 단편화
    - 패킷으로 쪼개어 통신
- 특징
  - 신뢰할 수 없는 비연결형 통신
    - 수신 보장이 안됨
    - 수신자의 연결 상태를 고려하지 않음

### IP 주소의 구조

```
123.45.123.45
```

- 네트워크 주소와 호스트 주소로 구성
  - 표현의 크기가 유동적이다.

#### 클래스풀 주소 체계

- A
  - **0**.0.0.0 ~ **127**.255.255.255
  - 첫번째 비트가 0
- B
  - **128**.**0**.0.0 ~ **191**.**255**.255.255
  - 첫번째 비트가 10
- C
  - **192**.**0**.**0**.0 ~ **223**.**255**.**255**.255
  - 첫번째 비트가 110
- 0번째 주소는 네트워크의 주소
- 마지막 주소는 브로드캐스트의 주소
- 고정된 크기, 주소가 낭비될 가능성이 존재

#### 클래스리스 주소 체계

- 서브넷 마스크
  - 네트워크 주소를 1, 호스트 주소를 0으로 표현
  - 11111111.0000000.0000000.0000000
  - 11111111.11111111.0000000.0000000
  - 11111111.11111111.11111111.0000000
- IP 주소와 서브넷 마스크의 주소를 `AND`하면 네트워크 주소를 알아낼 수 있음
  - 192.168.200.102 && 255.255.255.0 = 192.168.200.0

### IP 주소 할당

- DHCP
  - DHCP 서버가 사용가능한 IP 주소를 관리하다가 할당 요청 시에 할당
  - 사용 가능한 기간
  - 할당 받을 때 마다 IP 변경

</div>
</details>

<!-- # RAG -->

<!-- <details open> -->
<!-- <summary>Contents</summary> -->
<!-- <div markdown="1"> -->

<!-- </div> -->
<!-- </details> -->
